# 相似图片搜索原理

## 感知hash算法
对每张图片生成一个hash，然后比较不同图片的指纹，指纹越接近，说明图片越相似。

### 汉明距离
两个等长字符串之间对应位置不同字符的个数，或将一个字符串变成另外一个等长字符串所需要替换的字符个数。

### 实现过程
1. 缩小尺寸
将图片缩小到8*8的尺寸，得到64个像素的小图，这一步的作用是去除图片细节，只保留结构、明暗等基本信息，摈弃不同尺寸，比例带来的图片差异。
1. 简化色彩
转化为64级灰度，也就是所有像素点总共64种颜色
1. 计算平均值
计算64个像素的灰度平均值
1. 二值化
每个像素灰度与平均值比较， 大于或等于平均值记为1，否则记为0
1. 计算hash值
将二值化的结果组合一起，得到64位整数，这就是这张图片的指纹，要保证所有图片都采用同样的组合次序。
1. 对比指纹
计算两个指纹的汉明距离，如果不相同的数据位不超过5，说明很相似，如果大于10，说明是两张不同的图片

算法的优点是简单快速，不受图片大小缩放影响，缺点是图片的内容不能变更，如果在图片上加几个文字，就可能认不出来了。所以它的最佳用途是根据缩略图找出原图。

### 代码

[imageHash.js](./amWiki/snippets/imageHash.js)


## 颜色分步法
每张图片都可以生成颜色分步直方图，如果两张图片的直方图很接近，就可以认为他们很相似。

### 颜色直方图
（Color Histogram），指图像中颜色分步的图形表示，颜色直方图覆盖图像的整个色彩空间，标会各个颜色区间中的像素数

### 余弦相似度
用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异大小的度量
设：

向量$X = (x_1, x_2, ..., x_n)$

向量 $Y = (y_1, y_2, ..., y_n)$

余弦相似度：
$$sim(X, Y) = cos(\theta) = \frac{x_1y_1 + x_2y_2 + ... + x_ny_n}{\sqrt{x_1^2+x_2^2 + ... + x_n^2} + \sqrt{y_1^2+y_2^2 + ... + y_n^2}} $$


当X，Y向量夹角余弦等于1时，X,Y相等，接近于1时，X,Y相似；夹角越小，两个向量越不相似


### 实现过程
1. 对0~255分区
    每种原色都可以取256个值，那么整个颜色空间共有`256^3`种颜色，如果对每种颜色比较直方图，计算量太大，因此要采用分区的简化方法， 可以将0~255分成4个区
    （0区：0~63，1区：64~127，2区：127~191， 3区：192~255）,红绿蓝三原色总共可以构成64种组合
1. 统计每一种组合包含的像素数量
1. 将每种组合的像素数量组成64维向量，这个向量就是这张图片的特征值或者叫“指纹”
1. 计算两张图片的指纹相似度， 也就是计算两个向量的相似度































