# 系统设计

## SNAKE 五步系统设计法

以豆瓣FM为例

### Scenario 场景： 用例/接口

需要考虑到有哪些场景、场景有什么关系，关系怎么做到

1. 枚举
    - 登录/注册
    - 播放音乐
    - 音乐推荐
1. 排序（确定优先级）
    - 基本需求
        - 获得频道
        - 获得频道内音乐
        - 播放频道内音乐

### Necessary 限制：需求/假设

需要考虑限定条件

1. 询问
    - 用户数
1. 预测
    - 用户
        - 平均并发用户 = 日活用户 / 每日秒数 * 平均在线时长
        - 高峰并发用户 = 平均并发用户 * 6（经验值，不同系统不一样）
        - 3月后高峰并发用户 = 高峰并发用户 * 2
        - 用户量稳定后，可以考虑如何降低成本，比如减少服务器数量
    - 流量
        - 单用户流量
        - 3月后高峰流量 = 3月后高峰并发流量 * 单用户流量 （分布式CDN解决大流量）
    - 内存
        - 单用户内存
        - 3月后内存 = 单用户内存\*2\*日活用户
    - 存储
        - 音乐数 = 1,000,000
        - 总存储 = 音乐数 * 单音乐空间（不同码率，多个文件）

### Application (应用)： 服务/算法

- 重放用例，添加请求
- 组合服务

### Kilobit (数据)

- 为每个请求添加服务模块
- 选择存储方式
    - MySQL
    - MongoDB
    - Files

### Evolve (进化)

- 分析
    - 方向
        - 更好： 突破限制
        - 更广： 增加场景
        - 更深： 细节
    - 角度
        - 性能
        - 扩展
        - 鲁棒
- 回溯并进化

### 总结

S,N -> 输入 场景的线性条件
A,K,E -> 输出 应用架构和数据模型

- Scenario （场景）
    - 枚举&排序
- Necessary （限制）
    - 咨询&预测
- Application （应用）
    - 重放&组合
- Kilobit （数据）
    - 添加&选择
- Evolve （进化）
    - 分析&回溯

## 如何设计推荐模块

### 计算用户相似度

- 每个用户喜欢一批音乐
    - `u1 = {m3, m5, m7, m11}`
    - `u2 = {m1, m2, m3, m4, m5, m6, m7, m8, m9}`
- Simiarity(u1, u2) = 3 (请参考相似度算法)

### 推荐问题 -> 寻找一个用户的最相似用户

场景：接口

```java
interface Recommender{
    int findSimilarUser(int userID);
}
```

限定条件

- 预测
    - 3月后高峰用户 = 2,500,000
    - 计算频率 = 1 / 10min / user （每10分钟一次反馈）
    - 3月后高峰QPS = 3 月后高峰用户 \* 计算频率 = 2,500,000 \* 1 / (10*60) = 4167/s

算法 & 数据

1. v0 暴力遍历所有数据

m \* n \* k 算法， 速度很慢， 5qps

优化

1. v1 使用倒排索引

建立倒排索引的复杂度为 m \* n
计算相似度复杂度为 m
总的复杂度为 m \* n

优化后为 50qps

1. v2 预处理

使用离线架构，对数据预处理

1. v3 提高扩展性：添加分发器，使用多个Recommender来处理

1. v4 添加服务器

鲁棒性

