if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m001']=[{"name":"001-块级作用域.md","path":"001-前端开发/001-ECMAScript 6/001-入门/001-块级作用域.md","content":"# 块级作用域\r\n\r\n1. 避免块级变量提升带来的问题\r\n1. 支持任意嵌套\r\n1. 内层作用域和外层同名变量不冲突\r\n1. 不再需要立即执行函数表达式（IIFE）\r\n1. 允许在块级作用域声明函数，行为类似于`let`\r\n\r\n    **浏览器可以不遵守上面的规范，可以有自己的行为方式：**\r\n    - 允许在块级作用域内声明函数。\r\n    - 函数声明类似于`var`,会提升到全局作用域或者函数作用域的头部。\r\n    - 同时，函数声明会提升到所在的块级作用域的头部\r\n\r\n    **其它环境不用遵守**\r\n\r\n","timestamp":1524798865268},{"name":"001-gulpfile.js.md","path":"001-前端开发/001-ECMAScript 6/002-自动化/001-gulpfile.js.md","content":"## gulpfile.js\r\n\r\n\r\n### 安装\r\n\r\n```bash\r\nnpm i -D gulp gulp-sourcemaps gulp-rollup rollup-plugin-includepaths gulp-babel gulp-rename gulp-util gulp-hash-filename gulp-clean\r\n```\r\n\r\n### 内容\r\n\r\n```js\r\nconst [\r\n    gulp,\r\n    sourcemaps,\r\n    rollup,\r\n    rollupIncludePaths,\r\n    babel,\r\n    rename,\r\n    util,\r\n    hash,\r\n    clean\r\n] = [\r\n    \"gulp\",\r\n    \"gulp-sourcemaps\",\r\n    \"gulp-rollup\",\r\n    \"rollup-plugin-includepaths\",\r\n    \"gulp-babel\",\r\n    \"gulp-rename\",\r\n    \"gulp-util\",\r\n    \"gulp-hash-filename\",\r\n    \"gulp-clean\"\r\n].map(require);\r\n\r\nconst includePathOptions = {\r\n    paths: [\"src\"]\r\n};\r\ngulp.task(\"clean-dist\", () =>\r\n    gulp.src(\"dist/**/*.*\", {read: false})\r\n    .pipe(clean({\r\n        force: true\r\n    }))\r\n    .on(\"error\", util.log)\r\n);\r\ngulp.task(\"default\", [\"clean-dist\"], () =>\r\n    gulp.src([\"src/**/*.js\",\"!src/**/*.spec.js\"])\r\n\r\n    .pipe(sourcemaps.init())\r\n    .pipe(rollup({\r\n        entry: \"src/app.js\",\r\n        sourceMap: true,\r\n        plugins: [\r\n            rollupIncludePaths(includePathOptions)\r\n        ],\r\n        format: \"es\"\r\n    }))\r\n    .pipe(babel({\r\n        presets: [\r\n            [\"es2015\", {\"modules\": false}]\r\n        ],\r\n        babelrc: false\r\n    }))\r\n    .on(\"error\", util.log)\r\n    .pipe(rename(\"app.full.js\"))\r\n    .pipe(hash({\r\n        format: \"{name}.{hash:8}{ext}\"\r\n    }))\r\n    .pipe(sourcemaps.write(\".\"))\r\n    .pipe(gulp.dest(\"dist\"))\r\n);\r\n```\r\n### 效果\r\n合并脚本，在dist目录下生成 `app.full.{hash:8}.js` 和 `app.full.{hash:8}.js.map` 两个文件\r\n","timestamp":1524798865268},{"name":"099-ES6规范原文.md","path":"001-前端开发/001-ECMAScript 6/099-ES6规范原文.md","content":"<iframe src=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" style=\"width: 100%; height: 100%;border: 1px solid gray; margin: 0;\">\r\n</iframe>","timestamp":1524798865268},{"name":"001-CSS优先级逻辑.md","path":"001-前端开发/002-CSS/001-CSS优先级逻辑.md","content":"# CSS优先级逻辑\r\n\r\n","timestamp":1524798865268},{"name":"001-CSS Paint API.md","path":"001-前端开发/002-CSS/002-CSS Houdini/001-CSS Paint API.md","content":"# CSS Houdini -- CSS Paint API\r\n\r\n## 什么是CSS Houdini\r\n\r\n### CSS Houdini介绍\r\n\r\n### 浏览器支持\r\n\r\nApple, Google, Microsoft, Mozila, Opera都是Houdini项目的推动者，不过当前只有Chrome有实现。\r\n目前各浏览器实现程度如图：\r\n\r\n![CSS Houdini 兼容性](assets/001/002/002/001-1523858228000.png)\r\n\r\nCSS Houdini是包含了**Layout API**, **Paint API**等一系列API的统称， **Layout API**控制元素布局， **Paint API**控制CSS表达式处理参数逻辑。\r\n当前只有 **Paint API** 可以用， Chrome 65+ 已默认开启该接口，65以下的Chrome需要到 `chrome://flags` 开启 `Experimental Web Platform features`。\r\n\r\n### 如何检测\r\n\r\nJS:\r\n\r\n```js\r\nif (\'paintWorklet\' in CSS) {\r\n    // MAGICS\r\n}\r\n```\r\n\r\ncss:\r\n\r\n```CSS\r\n@supports (background: paint(id)) {\r\n    /* magics */\r\n}\r\n```\r\n\r\n<iframe height=\'265\' scrolling=\'no\' title=\'CSS Paint API Detection\' src=\'https://codepen.io/y1j2x34/embed/xWvwQg/?height=265&theme-id=0&default-tab=css,result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/y1j2x34/pen/xWvwQg/\'>CSS Paint API Detection</a> by y1j2x34 (<a href=\'https://codepen.io/y1j2x34\'>@y1j2x34</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\r\n</iframe>\r\n\r\n\r\n## 使用Paint API\r\n\r\n### 环境要求\r\n\r\n1. 使用Chrome浏览器， 低于65的要开启实验功能；\r\n1. 必须在支持https的服务上或本地 localhost才能用；\r\n\r\n### 简单示例\r\n\r\n### 过程说明\r\n\r\n### 自定义property\r\n\r\n### 自定义参数","timestamp":1524798865268},{"name":"001-webpack笔记.md","path":"001-前端开发/007-前端工具/001-webpack笔记.md","content":"# webpack 笔记\r\n\r\n## webpack安装和命令行\r\n\r\n### 安装\r\n\r\n    ```shell\r\n    npm i webpack -g\r\n    ```\r\n\r\n### 命令行\r\n\r\n#### 编译脚本\r\n\r\n```shell\r\nwebpack src.js bundle.js\r\n```\r\n\r\n#### 使用loader\r\n\r\n##### 如何在js中加载css\r\n\r\n1. 安装css-loader, style-loader\r\n    ```shell\r\n    npm i -D css-loader style-loader\r\n    ```\r\n1. 在js中引入\r\n\r\n    ```shell\r\n    require(\"style-loader!css-loader!style/xxx.css\")\r\n    ```\r\n    css-loader 用于引入css, style-loader用于将包含到js中的css插入html中，最终呈现效果\r\n\r\n##### 在命令行中声明loader\r\n\r\n    ```shell\r\n    webpack src.js bundle.js --module-bind \'css=style-loader!css-loader\'\r\n    ```\r\n\r\n#### 其它命令行参数\r\n\r\n1. --watch\r\n    监听文件变化，执行构建\r\n1. --progress\r\n    显示打包过程\r\n1. --display-modules\r\n    显示所引用的模块,包括loader处理\r\n1. --display-reasons\r\n    显示打包的模块理由（被谁依赖了）\r\n\r\n## webpack配置文件\r\n\r\n### entry配置\r\n\r\n1. 字符串 - 指定一个入口文件\r\n1. 数组 - 指定多个没有依赖关系的入口文件打包成一个\r\n1. 对象 - key： chunk value; value:和1,2两项规则一样， 多页面的使用场景会用到，\r\n     通过配置可以根据key生成对应的打包文件， 如果output的filename写死，最终生成的打包文件会发生覆盖，filename应使用占位符：\r\n    `name` key\r\n    `hash`  命令行输出内容的第一行的hash\r\n    `chunkhash` 每个chunk的hash\r\n\r\n### webpack 模板\r\n\r\n```shell\r\n<%=htmlWebpackPlugin.options.title %>\r\n```","timestamp":1524798865268},{"name":"001-setTimeout和setInterval.md","path":"001-前端开发/008-JavaScript/001-setTimeout和setInterval.md","content":"# 理解`setTimeout`和`setInterval`\r\n\r\n## `setTimeout()`\r\n\r\n### 语法 \r\n\r\n> ```js \r\n> var timeoutID = setTimeout(function[, delay, param1, param2, ...]);\r\n> var timeoutID = setTimeout(function[, delay])\r\n> var timeoutID = setTimeout(code[, delay])\r\n> ```\r\n\r\n### 参数\r\n\r\n- *function*\r\n    `function`是你想要`delay`毫秒后执行的函数\r\n- *code*\r\n    这是一个替代语法， 可以使用字符串代替`function`， 在`delay`毫秒之后执行字符串\r\n- *delay* （可选）\r\n    延迟的厚爱描述， 如果省略该参数，delay取默认值0.实际延迟时间可能比delay长。\r\n- *params1, ..., paramN* （可选）\r\n    附加参数\r\n\r\n\r\n### 返回值\r\n\r\n`timeoutID`是一个正整数， 表示定时器的编号。这个值可以传递给`clearTimeout()`来取消该定时器。\r\n\r\n`setTimeout()`和`clearInterval()`公用一个编号池，所以技术上是可以互换的， 但为了避免混淆，所以平常不要混用这两个函数。\r\n\r\n\r\n### 关于`this`的问题\r\n\r\n`setTimeout()`的回调函数里面的`this`不管在严格模式还是非严格模式下，都是指向window（或全局）对象， 并不是`undefined`。\r\n\r\n> **备注1：** 需要注意的是， IE9以及更早的IE浏览器不支持传递额外参数的功能，所以最好\r\n> 用其它兼容方案\r\n> ```js\r\n> var variable = 0;\r\n> setTimeout(function(){\r\n>   console.info(variable);\r\n> });\r\n>\r\n> setTimeout((function(variable){\r\n>  console.info(variable)\r\n> })(0))\r\n>\r\n>```\r\n\r\n> **备注2：** IE8-浏览器不允许定时器中传递事件对象`event`, 如果要使用事件对象中的某些属性， 可以将其保存在变量中传递出去。\r\n>\r\n> ```js\r\n> div.onclick = function(e){\r\n>     e = e || event;\r\n>     var type = e.type;\r\n>     setTimeout(function(){\r\n>         console.log(type); // click\r\n>         console.log(e.type); // IE8 下报错\r\n>     });\r\n> }\r\n> ```\r\n\r\n## `setInterval()`\r\n\r\n`setInterval`用法与`setTimeout`完全一致，区别于仅仅在于`setInterval`指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。\r\n\r\n>\r\n> HTML5标准规定，`setTimeout`的最短时间间隔是`4ms`,`setInterval`的最短间隔时间是`10ms`\r\n>\r\n\r\n## 运行机制\r\n\r\n解释下面的代码是先输出`0`而不是`1`的原因。\r\n\r\n```js\r\nsetTimeout(function(){\r\n    console.log(1)\r\n});\r\nconsole.log(0);\r\n```\r\n\r\n`delay`设为0并不是立即执行的意思，只是把函数放入代码队列。所以先输出`0`，再输出`1`\r\n\r\n\r\n再看一个例子\r\n\r\n```js\r\nbtn.onclick = function(){\r\n    setTimeout(funciton(){\r\n        console.log(1)\r\n    }, 250);\r\n};\r\n```\r\n\r\n如果`onclick`事件执行了`300ms`，则定时器至少要在定时器设置之后`300ms`后才会被执行。队列中的所有代码都要等到javascript进程空闲之后才能执行，而不管如何添加到队列。\r\n\r\n### `setInterval()`的问题\r\n\r\n定时器代码可能在代码再次被添加到队列之前还没有执行完，结果导致定时器代码连续运行好几次，而之间没有任何停顿。JS引擎的解决办法是： 仅当没有该定时器的任何其它代码示例时， 才将定时器代码添加到队列中， 确保了定时器代码加入到队列中的最小时间间隔为指定间隔。\r\n\r\n但也导致了两个问题：\r\n\r\n- 某些间隔被跳过\r\n- 多个定时器的代码执行之间的间隔可能比预期小\r\n\r\n假设， 某个`onclick`事件处理程序使用`setInterval()`设置了`200ms`间隔的定时器。如果事件处理程序花了`300ms`多一点时间完成，同时定时器代码也花了`300ms`的时间，就会出现跳过某间隔的情况：\r\n![](assets/001/008/001-1523375565000.png)\r\n\r\n可使用链式`setTimeout()`避免以上问题：\r\n\r\n```js\r\nsetTimeout(function fn(){\r\n    setTimeout(fn, interval);\r\n}, interval);\r\n```\r\n","timestamp":1524798865268},{"name":"002-requestAnimationFrame.md","path":"001-前端开发/008-JavaScript/002-requestAnimationFrame.md","content":"# requestAnimationFrame\r\n\r\n## 语法\r\n\r\n> ```js\r\n> window.requestAnimationFrame(callback)\r\n> ```\r\n\r\n### 参数\r\n\r\n`callback`： 一个指定函数的参数，该函数在下次重新绘制动画时调用，这个回调函数只有一个传参，`DOMHighResTimeStamp`, 指示`requestAnimationFrame()`开始触发回调函数的当前时间（`performance.now()`返回的时间）\r\n\r\n### 返回值\r\n\r\n一个`long`整数，请求ID，是回调列表中唯一的标识，非0值，用来取消回调函数：\r\n`window.cancelAnimationFrame()`\r\n\r\n### 范例\r\n\r\n```js\r\nvar start = null;\r\nfunction step(timestamp){\r\n    if(!start) {\r\n        start = timestamp;\r\n    }\r\n    var progress = timestamp - start;\r\n    element.style.left = Math.min(progress / 10, 200) + \'px\';\r\n\r\n    if(progress < 2000) {\r\n        requestAnimationFrame(step);\r\n    }\r\n}\r\nrequestAnimationFrame(step);\r\n```\r\n\r\n\r\n## 分析\r\n\r\n大多数显示器刷新频率是`60Hz`, 多数浏览器会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会提升，因此最平滑动画的最佳循环间隔是`1000ms/60`, 约为`16.6ms`。 `setTimeout`和`setInterval`的问题是，他们都不够精确，是运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间，如果队列中已有其它任务， 则动画代码就要等前面的任务完成了才能执行。\r\n\r\n`requestAnimationFrame`采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销，也不会因为间隔时间太长，使动画卡顿不流畅，让网页动画效果能有一个统一的刷新机制。\r\n\r\n### 特点\r\n\r\n- `requestAnimationFrame`会把每一帧的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率；\r\n- 在隐藏或不可见的元素中，`requestAnimationFrame`不会进行重绘或回流，减少CPU、GPU的开销；\r\n- `requestAnimationFrame`是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下，动画会自动暂停，节省CPU开销；\r\n\r\n### 兼容\r\n\r\n1. IE9-不兼容， 可用setTimeout来兼容；\r\n1. 若使用带前缀的版本，回调参数将是`DOMTimeStamp`而不是`DOMHighResTimeStamp`类，前者只精确到毫秒，后者精确到10微妙。此外，起始时间计算还不同，`DOMHighResTimeStamp`的起始时间与`performance.now()`相同，而 DOMTimeStamp 的起始时间与 Date.now() 相同；\r\n1. Chrome中正确取消回调的方法是 `window.cancelAnimationFrame()`， 旧版本 `window.webkitCancelAnimationFrame()`和`window.webkitCancelRequestAnimationFrame()` 已被启用， 但仍支持。\r\n1. Firefox 42中，已删除前缀版本的支持。","timestamp":1524798865268},{"name":"003-事件循环.md","path":"001-前端开发/008-JavaScript/003-事件循环.md","content":"","timestamp":1524798865268},{"name":"004-重绘和回流以及优化.md","path":"001-前端开发/008-JavaScript/004-重绘和回流以及优化.md","content":"# 页面重绘和回流（也有叫重排，英文：reflow）以及优化\r\n\r\n浏览器对页面的呈现的处理流程：\r\n\r\n```dot\r\ndigraph G {\r\n    HTML_Source -> Dom_Tree\r\n    CSS -> 样式结构体\r\n    Dom_Tree -> Render_Tree\r\n    样式结构体 -> Render_Tree\r\n    Render_Tree -> 绘制页面\r\n}\r\n```\r\n\r\n1. 浏览器吧获取到HTML代码解析成DOM树，每个tag都是DOM树中的一个节点，根节点为`document`对象。 DOM树包含所有HTML标签，包括`display:none`隐藏和JS动态添加的元素等；\r\n1. 浏览器把样式解析成样式结构体，同时去掉不能识别的样式；\r\n1. DOM Tree和样式结构体组合成Render Tree, Render Tree类似于样式结构体，但区别很大， Render Tree能识别样式，每个NODE都有自己的style，而且Render Tree不包含隐藏的节点（比如display: none, head节点）， visibility: hidden隐藏的元素会包含到Render Tree,因为会影响布局，占有空间。根据CSS2的标准，Render Tree的每个节点都称为Box（Box dimensions）， 理解页面元素为一个具有padding, margin, border 和 position的盒子；\r\n1. 一旦RenderTree构建完毕后，浏览器就可以根据Render Tree绘制页面；\r\n\r\n\r\n## 回流与重绘\r\n\r\n1. 当Render Tree中的一部分或全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，就称为回流（flow）。每个页面至少需要一次回流（页面第一次加载的时候）。在回流的时候，浏览器会使Render Tree中收到影响的部分失效，并重新构造这部分Render Tree, 完成回流后， 浏览器会重新绘制收到影响的部分到屏幕中，该过程成为重绘；\r\n\r\n1. 当Render Tree中的一些元素需要更新属性，而这些属性只是影响元素外观，风格，而不会影响布局的， 比如backgroud-color。这就称为重绘（因为不需要回流 ^_^）；\r\n\r\n重绘是回流引发的， 所以回流必然重绘， 重绘不一定要回流。\r\n\r\n### 回流在何时发生\r\n\r\n当页面布局和几何属性改变时就需要回流：\r\n\r\n1. 页面渲染初始化\r\n1. 脚本操作DOM\r\n1. 添加或删除可见的DOM元素\r\n1. 增加或移除样式表\r\n1. 操作class属性\r\n1. 激活CSS伪类\r\n1. 元素位置改变\r\n1. 元素尺寸改变--边距、填充、边框、宽度和高度\r\n1. 计算`offsetTop/Left/Width/Height`,`scrollTop/Left/Width/Height`等\r\n1. 改变字体\r\n1. 内容改变--文本改变或者图片大小改变引起的计算值宽度和高度\r\n1. 浏览器窗口尺寸改变--resize事件发生\r\n\r\n举个栗子：\r\n\r\n```js\r\nvar s = document.body.style\r\n\r\ns.padding = \'2px\'; // 回流加重绘\r\ns.border = \'1px solid red\'; // 再一次回流 + 重绘\r\ns.color = \'blue\'; // 再重绘\r\ns.backgroundColor= \'red\'; // 再重绘\r\ns.fontSize = \'14px\'; // 再一次回流 + 重绘\r\n// 添加Node，再一次回流+重绘\r\ndocument.body.appendChild(document.createTextNode(\'abc!\'));\r\n```\r\n\r\n## 优化\r\n\r\n1. 浏览器会维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者一定的时间间隔， 浏览器就会flush队列，进行一个批处理，让多次回流变一次回流重绘。\r\n1. 有时候需要强制浏览器提前flush队列，这样优化可能就起不到作用了，以下这些style信息在获取时，浏览器为了给出最精确的值而去flush队列：\r\n    - `offsetTop`,`offsetLeft`,`offsetWidth`,`offsetHeight`\r\n    - `scrollTop/Left/Width/Height`\r\n    - `clientTop/Left/Width/Height`\r\n    - `width`, `height`\r\n    - 请求了`getComputedStyle()`或者IE的`currentStyle`\r\n\r\n1. 减少回流/重绘的手段\r\n    1. 避免多级内联样式\r\n        因为每个都会造成回流，样式应合并到外部类，这样仅当改元素的class属性可被操控时仅会产生一个回流\r\n    1. 直接改变className,如果动态样式，直接用cssText(考虑没有优化的浏览器)\r\n        ```js\r\n        // bad \r\n        var left = 1;\r\n        var top = 1;\r\n        el.style.left = left + \'px\';\r\n        el.style.top = top + \'px\';\r\n\r\n        // good(add class)\r\n        el.className += \'className1\';\r\n\r\n        // good(css text)\r\n        el.style.cssText += `\r\n        left:${left}px;\r\n        top:${top}px\r\n        `;\r\n        ```\r\n    1. 让要操作的元素进行“离线处理”，处理完以后一起更新\r\n        a) 使用`DocumentFragment`进行缓存操作，引发一次回流和重绘；\r\n        b) 使用`display:none`技术，只引发两次回流和重绘；\r\n        c) 使用`cloneNode(true or false)`和`replaceChild`技术，引发一次回流和重绘\r\n    1. 不要经常访问会引起浏览器flush队列的属性，如果一定要访问，可适当加缓存处理\r\n        ```js\r\n        // bad\r\n        for(...) {\r\n            el.style.left = el.offsetLeft + 5 + \'px\';\r\n            el.style.top = el.offsetTop + 5 + \'px\';\r\n        }\r\n        // well\r\n        var left = el.offsetLeft, top = el.offsetTop, s = el.style;\r\n        for(...) {\r\n            left += 5;\r\n            top += 5;\r\n            s.left = left + \'px\';\r\n            s.top = top + \'px\';;\r\n        }\r\n        ```\r\n    1. 让元素脱离动画流， 减少回流的Render Tree的规模\r\n    1. 动画效果应用到position为absolute或fixed的元素上\r\n    absolute和fixed的元素不影响其它元素布局，所以只会导致重新绘制，而不是一个完整回流。\r\n    1. 牺牲平滑度换取速度\r\n        每次1像素移动一个动画，如果动画及随后产生的回流使用了100%的CPU，动画看上去就会是跳动的，因为浏览器正在与更新回流做斗争，所以必要时可以适当牺牲平滑度。\r\n        <!-- 如果高平滑度导致的回流占用大量资源，产生资源竞争，动画看起来会是跳动的， 所以可适当降低平滑度。 -->\r\n    1. 避免使用table布局\r\n        table上一些很小的变化都会导致表格中所有其它节点回流\r\n\r\n## 工具\r\n\r\n没找到~~","timestamp":1524798865268},{"name":"006-剪贴板.md","path":"001-前端开发/008-JavaScript/006-剪贴板.md","content":"# 剪贴板操作\r\n\r\n## 复制\r\n\r\n### 纯文本复制\r\n\r\n1. 使用`window.clipboardData`对象\r\n    ```js\r\n    window.clipboardData.setData(\'Text\', \'123456\');\r\n    ```\r\n1. 直接在输入框对象选择文本，在执行复制命令\r\n    ```html\r\n    <body>\r\n        <textarea  id=\"content\"></textarea>\r\n        <button id=\"copybtn\">拷贝</button>\r\n    </body>\r\n    <script>\r\n        var c = document.getElementById(\'content\');\r\n        var btn = document.getElementById(\'copybtn\');\r\n        btn.onclick = function() {\r\n            c.select();\r\n            document.execCommand(\'copy\');\r\n        };\r\n    </script>\r\n    ```\r\n1. 使用`createTextRange`方法\r\n    这种方法支持9以上的IE浏览器，可以同时复制图片和文本\r\n    ```html\r\n    <body>\r\n        <button id=\"copybtn\">拷贝</button>\r\n    </body>\r\n    <script>\r\n        var btn = document.getElementById(\'copybtn\');\r\n        btn.onclick = function() {\r\n            /* 使用一个临时的且不可见(不是display:none, 而是宽高为0)的textarea来复制文本*/\r\n            var tmp = document.createElement(\'textarea\');\r\n            tmp.style.cssText += \'width:0px;height:0px;padding:0;margin:0;position:fixed;top:0;left:0;\';\r\n            document.body.appendChild(tmp);\r\n            tmp.value = \"text to copy\";\r\n            var range = document.body.createTextRange();\r\n            range.moveToElementText(tmp);\r\n            range.select();\r\n            range.execCommand(\'copy\');\r\n            document.body.removeChild(tmp);\r\n        };\r\n    </script>\r\n    ```\r\n\r\n### 图片复制\r\n\r\n限制： 所拥有浏览器仅支持同源URL的图片， 非同源URL以及blob url, base64 data url均不支持复制。\r\n所以要实现复制图片数据流，就必须将图片数据上传到服务器生成一个图片URL。\r\n\r\n#### IE 中的实现方式\r\n\r\n1. 支持低版本IE\r\n    ```js\r\n    var img = document.getElementById(\'image-id\');\r\n    var range = document.body.createControlRange();\r\n    range.addElement(img);\r\n    range.execCommand(\'copy\');\r\n    ```\r\n\r\n1. 支持IE9及以上\r\n    ```html\r\n    <div id=\"wrapper-div\"><img src=\"/images/xxx.jpg\"></img></div>\r\n    <script>\r\n        var wrapperDiv = docuemnt.getElementById(\'wrapper-div\');\r\n        var range = document.body.createTextRange();\r\n        range.moveToElementText(wrapperDiv);\r\n        range.select();\r\n        range.execCommand(\'copy\');\r\n    </script>\r\n    ```\r\n    这种方法可以同时复制div中的图片以及文本。\r\n\r\n#### 其它浏览器\r\n\r\n和上面第二种方法相似\r\n    ```html\r\n    <div id=\"wrapper-div\"><img src=\"/images/xxx.jpg\"></img></div>\r\n    <script>\r\n        var wrapperDiv = docuemnt.getElementById(\'wrapper-div\');\r\n        var selection = window.getSelection();\r\n        selection.removeAllRanges();\r\n        var range = document.createRange();\r\n        range.selectNodeContents(wrapperDiv);\r\n        selection.addRange(range);\r\n        document.execCommand(\'copy\');\r\n        selection.removeAllRanges();\r\n    </script>\r\n    ```\r\n    也是可以同时复制div中的图片和文本\r\n\r\n## 各种事件\r\n\r\n`copy`事件\r\n用户通过键盘（Ctrl+C）或者右键菜单\"复制\"启动复制操作，并响应`document.execCommand(\'copy\')`调用时触发`copy`事件。\r\n\r\n通过监听该事件，调用`setData(mime, data)`修改`ClipboardData.clipboardData`事件的默认行为\r\n\r\n```js\r\ndocument.on(\'copy\', function(e){\r\n    e.clipboardData.setData(\'text/plain\', \'Hello world!\');\r\n    e.clipboardData.setData(\'text/html\', \'<b>Hello world!</b>\');\r\n    e.preventDefault(); // 阻止复制选中的内容， 改为上面设置的文本。\r\n})\r\n```\r\n\r\n不能使用`e.clipboardData.getData()`在事件处理函数中获取剪贴板内容。\r\n\r\n支持该事件的浏览器只有 Chrome(58), Edge, Firefox(22), Safari。\r\n\r\n`cut`事件\r\n\r\n`Ctrl+X`或者右键菜单\"剪切\"，或响应`document.execCommand(\'cut\')`时触发`cut`事件\r\n处理方法和`copy`事件相似，\r\n支持该事件的浏览器有：Chrome(58), Edge, Firefox(22), OPera(45)\r\n\r\n`paste`事件\r\n\r\n内容粘贴到页面中会触发该事件， 由于各个浏览器实现差异非常大， 所以要**谨慎**使用。\r\n\r\n支持的浏览器有： Chrome(58), Edge, Firefox(22), IE11(`e.clipboardData`为`window.clipboardData`), Opera(45), Safari。","timestamp":1524798865268},{"name":"007-严格模式.md","path":"001-前端开发/008-JavaScript/007-严格模式.md","content":"# JS 严格模式\r\n\r\n## 目录\r\n\r\n>1. [目录](#目录 \"目录\")\r\n1. [正文](#正文 \"正文\")\r\n    1. [目的](#目的 \"目的\")\r\n    1. [浏览器支持](#浏览器支持 \"浏览器支持\")\r\n    1. [进入标志](#进入标志 \"进入标志\")\r\n    1. [如何调用](#如何调用 \"如何调用\")\r\n    1. [语法和行为改变](#语法和行为改变 \"语法和行为改变\")\r\n\r\n## 正文\r\n\r\n### 目的\r\n\r\n>\r\n> 1. 消除不合理、不严谨的代码，减少怪异行为\r\n> 1. 消除代码不安全之处\r\n> 1. 提高解释器效率，增加运行速度\r\n>\r\n\r\n### 浏览器支持\r\n\r\n包括IE10在内的主流浏览器均支持\r\n\r\n### 进入标志\r\n\r\n```js\r\n\"use strict\"\r\n```\r\n\r\n不支持的浏览器会以普通字符串忽略\r\n\r\n### 如何调用\r\n\r\n1. 针对整个脚本文件\r\n\r\n将\"use strict\"放在脚本 **第一行**， 则整个脚本都以严格模式执行。\r\n要特别注意，不同模式的代码（lib）合并一个文件，可能会导致合并后的脚本无法执行\r\n\r\n1. 针对单个函数\r\n\r\n将`\"use strict\"`放在函数体的第一行，整个函数以“严格模式”运行\r\n\r\n```js\r\nfunction strict(){\r\n    \"use strict\";\r\n    return \"严格模式\";\r\n}\r\nfunction notStrict(){\r\n    return \"正常模式\";\r\n}\r\n```\r\n\r\n1. 脚本文件的变通写法\r\n\r\n因为第一种不利于脚本脚本合并，所以可以借用第二种方法，将脚本文件放在一个立即执行的匿名函数中\r\n\r\n```js\r\n(function(){\r\n    \"use strict\";\r\n\r\n    // code\r\n})();\r\n```\r\n\r\n### 语法和行为改变\r\n\r\n1. 全局变量显示声明\r\n\r\n```js\r\n\"use strict\";\r\nv = 1; // 报错\r\nfor(i=0;i<2;i++){ // 报错\r\n}\r\n```\r\n\r\n1. 静态绑定\r\n    1. 禁止with语句\r\n    ```js\r\n    \"use strict\"\r\n    var o = {v: 2};\r\n    var v = 1;\r\n    with(o){ // 报错\r\n        v = 3;\r\n    }\r\n    ```\r\n    1. eval作用域\r\n    正常模式只有全局作用域和函数作用域，严格模式下增加第三种：eval作用域\r\n    正常模式下eval语句的作用于取决于它说出的作用域，严格模式下eval语句本身就是一个作用域，不能生成全局变量\r\n    ```js\r\n    \"use strict\";\r\n    var x = 2;\r\n    console.info(eval(\"var x = 5; x\")); // 5\r\n    console.info(x); // 2\r\n    ```\r\n1. 增强的安全措施\r\n    1. 禁止this关键字指向全局对象\r\n    ```js\r\n    function f(){\r\n        return !this;\r\n    } \r\n    // f() returns false, this指向全局对象\r\n    function f(){\r\n        \"use strict\";\r\n        return !this;\r\n    } \r\n    // f() returns true, 严格模式下，this的值为undefined\r\n    ```\r\n    使用构造函数时，如果忘了加new，则报错\r\n    ```js\r\n    function f(){\r\n        \"use strict\";\r\n        this.a = 1;\r\n    }\r\n    f(); // 报错\r\n    ```\r\n    1. 禁止在函数内部遍历调用栈\r\n    ```js\r\n    function f(){\r\n        \"use strict\";\r\n        f.caller; // 报错\r\n        f.arguments; // 报错\r\n    }\r\n    f();\r\n    ```\r\n1. 重名错误\r\n    1. 对象不能有重名属性\r\n    ```js\r\n    \"use strict\";\r\n    var o = {\r\n        a: 1,\r\n        a: 2\r\n    } // 语法错误\r\n    ```\r\n    1. 函数不能有重名参数\r\n    ```js\r\n    \"use strict\"\r\n    function (a, a, b){ // 语法错误\r\n        return;\r\n    }\r\n    ```\r\n\r\n1. 函数必须声明在顶层\r\n\r\n```js\r\n\"use strict\";\r\nif(cond){\r\n    function f1(){} // 语法错误\r\n}\r\nfor(var i = 0 ;i < 100;i++){\r\n    function f2(){} // 语法错误\r\n}\r\n```\r\n\r\n1. 保留字\r\n\r\n这些保留字不能作为变量\r\n\r\n```js\r\nimplements, interface, let, package, private, protected, public, static, yield\r\n```\r\n\r\n```js\r\nfunction package(protected){ // 报错\r\n    \"use strict\";\r\n    var static; // 报错\r\n}\r\n```","timestamp":1524798865268}]