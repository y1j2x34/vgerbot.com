if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=[{"name":"001-基本语法.md","path":"006-编程语言/005-kotlin/001-入门知识/001-基本语法.md","content":"# Kotlin基本语法\r\n\r\n### package\r\npackage应定义在文件顶部\r\n```kotlin\r\npackage my.demo\r\nimport java.util.*;\r\n// ...\r\n```\r\nkotlin不强制要求包和目录要匹配，源文件可以放在任意目录中\r\n\r\n### 定义函数\r\n\r\n```kotlin\r\n// 接收两个Int类型参数并返回Int类型的结果\r\nfun sum(a: Int, b: Int): Int{\r\n    return a + b\r\n}\r\n```\r\n```kotlin\r\n// 使用表达式函数体&返回类型推断\r\nfun sum(a: Int, b: Int) = a + b\r\n```\r\n\r\n```kotlin\r\n// 无返回\r\nfun printSum(a: Int, b: Int): Unit {\r\n    println(\"sum og $a and $b is ${a + b}\")\r\n}\r\n// Unit可以省略\r\nfun printSum2(a: Int, b: Int){\r\n    println(\"sum og $a and $b is ${a + b}\")\r\n}\r\n```\r\n\r\n### 局部变量定义\r\n\r\n不可变局部变量\r\n```kotlin\r\nfun main(arg: Array<String>) {\r\n    val a: Int = 1 // 立即赋值\r\n    val b = 2 // 自动推断出Int类型\r\n    val c: Int // 没有初始值的情况必须要提供类型声明\r\n    c = 3 // 延迟赋值\r\n\r\n    println(\"a = $a, b = $b, c = $c\")\r\n}\r\n```\r\n\r\n### 注释\r\n与Java，JavaScript一致,kotlin支持行注释和块注释， 不同的是kotlin的块注释支持嵌套\r\n\r\n```kotlin\r\n// This is an end-of-line comment\r\n\r\n/*\r\n    This is a block comment\r\n    on multiple lines. */\r\n\r\n```\r\n\r\n### 字符串模板\r\n\r\n\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    var a = 1\r\n    val s1 = \"a is $a\"\r\n    a = 2\r\n\r\n    val s2 = \"${s.erplace(\"is\", \"was\")}, but now is $a\"\r\n\r\n    println(s2)\r\n}\r\n```\r\n### 条件语句\r\n\r\n```kotlin\r\nfun maxOf(a: Int, b: Int) {\r\n    if(a > b){\r\n        return a\r\n    } else{\r\n        return b;\r\n    }\r\n}\r\nif表达式\r\n```\r\n```kotlin\r\nfun maxOf(a: Int, b: Int) = if(a > b) a else b\r\n```\r\n\r\n### 使用可空值和空值检查\r\n\r\n引用的值如果可能为空的情况必须标记为可空,表现为`类型?`形式\r\n\r\n```kotlin\r\nfun parseInt(str: String): Int?{\r\n    return str.toIntOrNull()\r\n}\r\n\r\nfun printProduct(a: String, b: String){\r\n    val x = parseInt(x)\r\n    val y = parseInt(y)\r\n\r\n    // x,y可能会出现空值而导致异常\r\n    if(x != null && y != null) {\r\n        println(x * y)\r\n    } else{\r\n        print;n(\"either \'$a\' or \'$b\' is not a number\");\r\n    }\r\n}\r\n```\r\n### 类型检查和类型自动转换\r\n\r\n`is` 运算符用来检测表达式是否为一个类型的实例。如果不可变变量或者属性通过检查为一个指定类型的实例，\r\n则可以不需要做显示转换\r\n\r\n```kotlin\r\nfun getStringLength(obj: Any): Int? {\r\n    if(obj is String){\r\n        //  在这个条件分支下，`obj`被自动转为`String`类型， 可以直接使用String的length而不需要做显示转换\r\n        return obj.length\r\n    }\r\n    // 在上面的条件分支外，`obj`还是`Any`类型\r\n    return null\r\n}\r\n// 或者也可以这么写\r\nfun getStringLength(obj: Any): Int? {\r\n    if(obj !is String) return;\r\n    // 这里也会自动转为String\r\n    return obj.length;\r\n}\r\n```\r\n\r\n### for循环用法\r\n\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val items = listOf(\"Apple\", \"Banana\", \"kiwi\")\r\n    for(item in items) {\r\n        println(item)\r\n    }\r\n}\r\n```\r\n\r\nor\r\n\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val items = listOf(\"Apple\", \"Banana\", \"kiwi\")\r\n    for(index in items.indices){\r\n        println(\"item at $index is ${items[index]}\")\r\n    }\r\n}\r\n```\r\n\r\n### while循环用法\r\n\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val items = listOf(\"Apple\", \"Banana\", \"kiwi\")\r\n    var index = 0;\r\n    while(index < items.size){\r\n        println(\"item at $index is ${items[index]}\");\r\n        index ++ ;\r\n    }\r\n}\r\n```\r\n\r\n### when表达式用法\r\n\r\n```kotlin\r\nfun describe(obj: Any): String =\r\n    when(obj) {\r\n        1 -> \"One\"\r\n        \"Hello\" -> \"Greeting\"\r\n        is Lone -> \"Long\"\r\n        !is String -> \"Not a string\"\r\n        else -> \"Unknown\"\r\n    }\r\n```\r\n\r\n### 区间（range）用法\r\n\r\n`in`操作符检查数字是否在某个指定区间内\r\n\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val x = 10\r\n    val y = 9\r\n\r\n    if(x in 1..y+1){\r\n        println(\"fits in range\");\r\n    }\r\n}\r\n```\r\n`!in`检查数字是否在区间外\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val list = listOf(\"a\", \"b\", \"c\")\r\n\r\n    if(-1 !in 0..list.lastIndex){\r\n        println(\"-1 is out of range\");\r\n    }\r\n    if(list.size !in list.indices) {\r\n        println(\"list size is out of valid list indices range too\")\r\n    }\r\n}\r\n```\r\n\r\n区间迭代\r\n```kotlin\r\nfun main(args: Array<String>){\r\n    for (x in 1..5){\r\n        println(x)\r\n    }\r\n}\r\n```\r\n\r\n迭代步长\r\n\r\n```kotlin\r\nfun main(args: Array<String>){\r\n    for (x in 1..10 step 2){\r\n        println(x)\r\n    }\r\n    for (x in 9 downTo 0 step 3){\r\n        println(x)\r\n    }\r\n}\r\n```\r\n\r\n集合用法\r\n\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\r\n    for (item in items){\r\n        println(item)\r\n    }\r\n}\r\n```\r\n使用`in`检查集合中是否包含实例\r\n```kotlin\r\nfun main(args: Array<String>) {\r\n    val item = setOf(\"apple\", \"banana\", \"kiwi\")\r\n    when {\r\n        \"orange\" in items -> println(\"juicy\")\r\n        \"apple\" in items -> println(\"apple is fine too\")\r\n    }\r\n}\r\n```\r\n\r\nlambda表达式：filter & map\r\n\r\n```kotlin\r\nfun main(args: Array<String>){\r\n    val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwi\")\r\n\r\n    fruits //\r\n        .filter {it.startsWith(\"a\")} //\r\n        .sortedBy {it } //\r\n        .map {it.toUpperCase() } //\r\n        .forEach{ println(it) }\r\n}\r\n```\r\n","timestamp":1524798865268},{"name":"002-习惯用法.md","path":"006-编程语言/005-kotlin/001-入门知识/002-习惯用法.md","content":"# 习惯用法\r\n\r\n### 创建DTOs(POJOs/POCOs)数据类\r\n```kotlin\r\ndata class Customer(val name: String, val email: String)\r\n```\r\nCustomer类会自动添加下列函数：\r\n- `getters`,如果为var类型，还会添加`setters`，\r\n- `equals()`,\r\n- `hashCode()`,\r\n- `toString()`,\r\n- `copy()`,\r\n- `compoment1()`, `component2()`...\r\n\r\n### 函数参数默认值（可以联想到Java的方法重载写法）\r\n```kotlin\r\nfun foo(a: Int = 0, b: String = \"\") {...}\r\n```\r\n\r\n### 过滤\r\n\r\n```kotlin\r\nval positives = list.filter { x -> x > 0}\r\n```\r\n\r\n更精简的写法\r\n```kotlin\r\nval positives = list.filter { it > 0}\r\n```\r\n\r\n### 字符串插值\r\n\r\n```kotlin\r\nval name = \"Mario\";\r\nprintln(\"Name $name\")\r\n```\r\n\r\n### 实例类型检查\r\n\r\n```kotlin\r\nwhen (instance){\r\n    is Foo -> ...\r\n    is Bar -> ...\r\n    else -> ...\r\n}\r\n```\r\n\r\n### 遍历map\r\n```kotlin\r\nfor ( (k, v) in map){\r\n    println(\"$k -> $v\");\r\n}\r\n```\r\n\r\n### 使用ranges\r\n\r\n```kotlin\r\nfor (i in 1..100) {...} // 闭区间， 包括100\r\nfor (i in 1 until 100) {...} // 半开区间， 不包括100\r\nfor (i in 2..10 step 2) {...}\r\nfor (i in 10 downTo 1) {...}\r\nif(x in 1..10){...}\r\n```\r\n\r\n### 只读列表\r\n\r\n```kotlin\r\nval list = listOf(\"a\", \"b\", \"c\");\r\n```\r\n\r\n### 只读map\r\n\r\n```kotlin\r\nval map = mapOf(\r\n    \"a\" to 1,\r\n    \"b\" to 2,\r\n    \"c\" to 3\r\n)\r\n```\r\n\r\n### 访问map\r\n```kotlin\r\nprintln(map[\"key\"])\r\nmap[\"key\"] = value\r\n```\r\n\r\n### 懒属性\r\n\r\n```kotlin\r\nval p: String by lazy {\r\n    // 生成String值\r\n}\r\n```\r\n\r\n### 扩展函数\r\n\r\n```kotlin\r\n// 转为驼峰式\r\nfun String.spaceToCamelCase(){...}\r\n\"Convert this to camelcase\".spaceToCamelCase()\r\n```\r\n\r\n### 单例\r\n\r\n```kotlin\r\nobject Resource {\r\n    val name = \"Name\"\r\n}\r\n```\r\n\r\n### 不为空则。。。\r\n```kotlin\r\n    val files = File(\"Test\").listFile()\r\n    println(files?.size)\r\n```\r\n### 不为空。。。否则。。。\r\n\r\n```kotlin\r\nval files = File(\"Test\").listFiles()\r\nprintln(files?.size ?: \"empty\")\r\n```\r\n\r\n### 为空则。。。\r\n\r\n```kotlin\r\nval data = ...\r\nval email = data[\"email\"] ?: throw IllegalStateException(\"Email is missing\")\r\n```\r\n\r\n### 不为空则执行。。。\r\n\r\n```kotlin\r\nval data = ...\r\ndata?.let{\r\n    ... // 如果不为空则执行这个代码块\r\n}\r\n```\r\n\r\n### 如果不为空执行某操作否则。。。\r\n```kotlin\r\nval data = ...\r\nval mapped = data?.let { transformData(it) } ?: defaultValueIfDataIsNull\r\n```\r\n\r\n### 返回`when`语句\r\n\r\n```kotlin\r\nfun transform(color: String): Int {\r\n    return when(color){\r\n        \"Red\" -> 0\r\n        \"Green\" -> 1\r\n        \"Blue\" -> 2\r\n        else => throw IllegalArgumentException(\"Invalid color param value\")\r\n    }\r\n}\r\n```\r\n\r\n### `try/catch`表达式\r\n\r\n```kotlin\r\nfun test(){\r\n    val result = try {\r\n        count()\r\n    } catch(e: ArithmeticException) {\r\n        throw IllegalStateException(e)\r\n    }\r\n}\r\n```\r\n\r\n### `if`表达式\r\n\r\n```kotlin\r\nfun foo(param: Int){\r\n    val result = if(param == 1) {\r\n        \"one\"\r\n    } else if(param == 2) {\r\n        \"two\"\r\n    } else {\r\n        \"three\"\r\n    }\r\n}\r\n```\r\n\r\n### 使用生成器模式返回Unit\r\n```kotlin\r\nfun arrOfMinusOnes(size: Int) : IntArray {\r\n    return IntArray(size).apply {fill(-1)}\r\n}\r\n```\r\n\r\n### 单表达式函数\r\n```kotlin\r\nfun theAnswer() = 42\r\n```\r\n等同于\r\n```kotlin\r\nfun theAnswer(): Int {\r\n    return 42\r\n}\r\n```\r\n可以和其它惯用语组合成高效简洁的代码， 比如`when`,`if`表达式等：\r\n```kotlin\r\nfun transform(color: String): Int = when (color) {\r\n    \"Red\" -> 0\r\n    \"Green\" -> 1\r\n    \"Blue\" -> 2\r\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\r\n}\r\n```\r\n\r\n### 利用`with`调用一个对象上多个方法（参考JavaScript）\r\n\r\n```kotlin\r\nclass Turtle {\r\n    fun penDown()\r\n    fun penUp()\r\n    fun turn(degrees: Double)\r\n    fun forward(pixels: Double)\r\n}\r\n\r\nvar myTurtle = Turtle()\r\n// draw a 100 pix square\r\nwith(myTurtle) {\r\n    penDown()\r\n    for(i in 1..4) {\r\n        forward(100.0)\r\n        tuen(90.0)\r\n    }\r\n    penUp()\r\n}\r\n```\r\n\r\n### Java7\'s try with resources\r\n\r\n```kotlin\r\nval stream Files.newInputStream(Paths.get(\"/some/file.txt\"))\r\nstream.buffered().reader().use {\r\n    reader - > println(reader.readText())\r\n}\r\n```\r\n\r\n### 需要泛型信息的函数的方便形式\r\n```kotlin\r\n// public final class Gson {\r\n//    ...\r\n//    public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException{\r\n        // ...\r\n\r\n    inline fun <reified T: Any> Gson.fromJson(json): T = this.fronJson(json, T::class.java)\r\n\r\n```\r\n\r\n### 使用可能为空的Boolean值\r\n\r\n```kotlin\r\nval b:Boolean? = ...\r\nif(b == true){\r\n    ...\r\n} else {\r\n    // `b` is false or null\r\n}\r\n```\r\n","timestamp":1524798865268},{"name":"003-编码规范.md","path":"006-编程语言/005-kotlin/001-入门知识/003-编码规范.md","content":"# 编码规范\r\n\r\n### 命名风格\r\n\r\n默认使用Java编码规范，例如：\r\n\r\n- 使用驼峰命名法（需避免使用下划线）\r\n- 类型以大写字母开头\r\n- 方法和属性名使用小写字母开头\r\n- 缩进使用四个空格\r\n- 公共函数需要有说明文档\r\n\r\n### 冒号\r\n\r\n子类和父类之间的冒号两边都加空格， 实例和类型之间的冒号后边加空格\r\n\r\n```kotlin\r\ninterface Foo<out T : Any> : Bar {\r\n    fun foo(a: Int): T\r\n}\r\n```\r\n\r\n### lambda表达式\r\n\r\nlambda表达式中的大括号前后都加空格，以及分隔参数和函数体的箭头前后也要加空格。\r\n\r\n```kotlin\r\nlist.filter { it > 10 }.map { element -> element * 2 }\r\n```\r\nlambda表达式应尽可能简短而且要避免嵌套，推荐使用`it`而不是显式地声明参数，在使用嵌套的lambda表达式中，参数则应该显示声明。\r\n\r\n### 类型声明\r\n\r\n参数较少的情况写成一行\r\n```kotlin\r\nclass Person(id: Int, name: String)\r\n```\r\n\r\n参数较多的情况， 那么每个参数都独立一行且带缩进， 闭括号也在新行上。如果有使用继承，那么超类构造函数调用或实现的接口列表应该位于与闭括号相同的行中。\r\n\r\n```kotlin\r\nclass Person(\r\n    id: Int,\r\n    name: String,\r\n    surname: String\r\n) : Human(id, name) {\r\n    // ...\r\n}\r\n```\r\n\r\n多个接口或者超类构造函数调用需要另起新行，每个接口须占一行\r\n\r\n```kotlin\r\nclass Person(\r\n    id: Int,\r\n    name: String,\r\n    surname: String\r\n) : Human(id, name),\r\n    KotlinMaker {\r\n        // ...\r\n}\r\n```\r\n\r\n构造函数参数可以使用常规缩进或者连续缩进\r\n\r\n### Unit\r\n返回Unit的函数，返回类型应该要省略。\r\n```kotlin\r\nfun foo() {\r\n\r\n}\r\n```\r\n\r\n### 函数VS属性\r\n\r\n在某些情况下，无参函数能和只读属性通用。尽管语义上是相似的， 但是有一些风格约定\r\n\r\n\r\n符合下列情况的场景更偏向于使用属性而不是函数\r\n\r\n- 不需要抛异常\r\n- `O(1)`复杂度\r\n- 低消耗的计算（第一次调用结果会被缓存）\r\n- 每次调用返回结果都相同\r\n","timestamp":1524798865268},{"name":"001-基本类型.md","path":"006-编程语言/005-kotlin/002-基础/001-基本类型.md","content":"# 基本类型\r\n在kotlin的世界里，所有的东西都是对象，因此我们可以调用任意变量的成员函数\r\n或者获取属性。有一些内建的类型，看起来和普通的类一样，但实际上内部有做过优化。\r\n这个部分我们来介绍这类类型， 比如： 数字、字符、布尔以及数组。\r\n\r\n## 数字\r\nkotlin处理数字的方式和Java很相似，会有一些差别，举两个栗子，kotlin的数字没有做隐式类型拓宽转换（比如java中int可以隐式转换为long）以及字面写法会略有不同。\r\n\r\n与Java相同， kotlin也提供以下这几类内建数字类型：\r\n|类型|位宽|\r\n|-|-|\r\n|Double|64|\r\n|Float|32|\r\n|Long|64|\r\n|Int|32|\r\n|Short|16|\r\n|Byte|8|\r\n\r\n**注意**： 字符在kotlin里面不是数字\r\n\r\n### 字面常量\r\n下面列出整数值的几种字面常量写法\r\n- 十进制： `123`\r\n    - `Long`长整型使用大写`L`标记：`123L`\r\n- 十六进制： `0x0F`\r\n- 二进制： `0b00001011`\r\n\r\n**注意**：不支持8进制整数写法\r\n\r\nKotlin同时也支持常规的浮点数写法：\r\n- 默认为双精度：`123.5`,`123.5e10`\r\n- 单精度小数需要加`f`或者`F`： `123.5f`\r\n\r\n\r\n### 数字字面量中带下划线\r\n\r\n使用下划线使数字可读性更高\r\n\r\n```kotlin\r\nval oneMillion = 1_000_000;\r\nval creditCardNumber = 1234_5678_9012_3456L\r\nval socialSecurityNumber = 999_99_9999L\r\nval hexbytes = 0xFF_EC)DE)5E\r\nval bytes = 0b11010010_01101001_10010100_10010010\r\n```\r\n\r\n### 表现\r\n\r\nJava平台上， 数字被物理存储为JVM的原生类型， 除非需要一个可空的引用或泛型，在后面的情况下，数字会被装箱。\r\n\r\n要注意的是， 装箱不会保留同一性：\r\n```kotlin\r\nval a:Int = 10000\r\nprint(a === a) // true\r\nval boxedA: Int? = a\r\nval anotherBoxedA: Int? = a\r\nprint(boxedA === anotherBoxedA) // false\r\n```\r\n\r\n另一方面， 它保留了相等性：\r\n```kotlin\r\nval a:Int = 1000\r\nprint(a == a) // true\r\nval boxedA: Int? = a\r\nval anotherBoxedA: Int? = a\r\nprint(boxedA == anotherBoxedA)\r\n```\r\n\r\n### 显式转换\r\n\r\n由于表示方式不同，较小类型并不是较大类型的子类。如果是话，就会出现下面的问题：\r\n\r\n```kotlin\r\n// 假想的代码， 实际上是编译不通过的\r\nval a: Int? = 1 // 装箱的Int\r\nval b: Long? = a // 隐式转换为装箱的Long\r\nprint(a == b) // 由于Long的equals方法会检测其它类型是否为Long，这里会输出false\r\n```\r\n上面的例子如果成立，装箱后的相等性和同一性也将不复存在\r\n\r\n相似类型不能隐式转换为更大的类型，这也意味着我们不能将`Byte`类型的值没有显式转换地赋值给`Int`\r\n\r\n```kotlin\r\nval b: Bye = 1\r\nval i: Int = b // ERROR\r\n```\r\n显式转换的写法：\r\n```kotlin\r\nval i: Int = b.toInt()// OK: 显示加宽类型\r\n```\r\n\r\n所有数字类型都支持以下转换方法：\r\n- `toByte(): Byte`\r\n- `toShort(): Short`\r\n- `toInt(): Int`\r\n- `toLong(): Long`\r\n- `toFloat(): Float`\r\n- `toDouble(): Double`\r\n- `toChar(): Char`\r\n\r\n\r\n类型可以从上下文推断，算术运算会有重载做适当转换\r\n```kotlin\r\nval l = 1L + 3 // Long + Int => Long\r\n```\r\n\r\n\r\n### 运算符\r\n\r\nKotlin支持数字上的标准算术运算符，这些运算符都被定义成相应的类成员（但编译器会优化成相应指令）。\r\n见[运算符重载<暂未翻译>](xxx)\r\n\r\nkotlin没有给位运算符定义一些特殊符号， 只是一些命名好的函数以中缀表达式形式编写， 例如：\r\n\r\n```kotlin\r\nval x = (1 shl 2) and 0x000FF000\r\n```\r\n\r\n位运算符列表：\r\n- `shl` 左移\r\n- `shr`  右移\r\n- `ushr` 无符号右移\r\n- `and` 与\r\n- `or` 或\r\n- `xor` 异或\r\n- `inv` 非\r\n\r\n### 字符\r\n\r\n字符使用`Char`类型表示， 和Java不同， Kotlin的字符不能直接视为数字处理\r\n\r\n```kotlin\r\nfun check(c: Char){\r\n    if (c == 1){ // ERROR : 类型不匹配\r\n\r\n    }\r\n}\r\n```\r\n字符字面量使用单引号包围，特殊字符可以可以使用反斜杠转义：\r\n`\\t`,`\\b`,`\\n`,`\\r`, `\\\'`, `\\\"`, `\\\\` 以及`\\if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=。\r\n其它特殊字符可以使用Unicode转义序列写法：`\\uFF00`\r\n我们可以显式转换字符为`Int`数字：\r\n\r\n```kotlin\r\nfun decimalDigitValue(c: Value): Int {\r\n    if(c !in \'0\'..\'9\')\r\n        throw IllegalArgumentException(\"Ot of range\")\r\n    return c.toInt() - \'0\'.toInt() // 显式转换为Int类型数字计算\r\n}\r\n```\r\n和数字一样， 在可以为空的引用上字符会被装箱，装箱操作不会保留同一性\r\n\r\n## 布尔\r\n\r\n`Boolean`表示布尔类型，两个值：`true`和`false`\r\n可空引用会被装箱\r\n\r\n内建布尔运算包含：\r\n- `||` 逻辑或\r\n- `&&` 逻辑与\r\n- `!` 非\r\n\r\n## 数组\r\n\r\n在Kotlin中数组以Array类来表示，其定义了`get`和`set`函数（通过运算符重载变成`[]`）、`size`\r\n属性以及其它有用的成员函数：\r\n\r\n```kotlin\r\nclass Array<T> private constructor(){\r\n    val size: Int\r\n    operator fun get(index: Int): T\r\n    operator fun set(index: Int, value: T): Unit\r\n\r\n    operator fun iterator(): Iterator<T>\r\n}\r\n```\r\n我们可以使用库函数`arrayOf()`来创建数组，例如`arrayOf(1,2,3)`创建出来一个`[1,2,3]`的数组，\r\n另外，`arrayOfNulls()`函数可以用于创建指定大小且填充`null`元素的数组。\r\n\r\n另一个选项是用接收数组大小和一个工厂函数，工厂函数会返回索引上的元素的初始值。\r\n\r\n```kotlin\r\n// 创建一个Array<String>类型的数组，初始化为：[\"0\",\"1\",\"4\",\"9\",\"16\"]\r\nval asc = Array(5, {i -> (i * i).toString()})\r\n```\r\n如上所述，`[]`操作符代表调用数组的成员函数`get()`和`set()`\r\n\r\n**注意**：与Java不同， Kotlin的数组是不型变的（invariant）, 所以Array<String>类型数组的\r\n值不能赋值给Array<Array>, 这样能避免一些运行时错误（但是可以用 Array<out Any>做到型变）\r\n\r\n同时， Kotlin也有提供一些专门的类来表示基本类型的数组，没有装箱拆箱开销，如：`ByteArray`,\r\n`ShortArray`,`IntArray`等等，这些类型和`Array`没有继承关系，但是他们有相同的方法和属性，\r\n且都有一个相应的工厂函数：\r\n```kotlin\r\nval x: IntArray = intArrayOf(1, 2, 3)\r\nx[0] = x[1] + x[2]\r\n```\r\n## 字符串\r\n字符串用`String`类来表示，字符串不可变，由字符组成，可以使用索引获取：`s[i]`。字符串可以用for循环迭代\r\n\r\n```kotlin\r\nfor(c in str){\r\n    println(c)\r\n}\r\n```\r\n## 字符串字面量\r\nKotlin有两种字符串字面量：转义字符串可以转义其中的字符和原生字符串，可以包含换行符和任意文本。\r\n转义字符串和Java字符串很相似\r\n```kotlin\r\nval s = \"Hello, world!\\n\"\r\n```\r\n转义采用传统的反斜杠方式，参见上面的[字符](/xxx)查看支持的转义序列\r\n\r\n原生字符串由三个双引号（`\"\"\"`）分界符括起来，内部没有转义，可以包含行以及任意字符\r\n```kotlin\r\nval text = \"\"\"\r\n    for (c in \"foo\")\r\n        print(c)\r\n\"\"\"\r\n```\r\n\r\n使用`trimMargin()`函数可以删除前导空格\r\n```kotlin\r\nval text = \"\"\"\r\n    |Tell me and I forget\r\n    |Teach me and I remember\r\n    |Involve me and I learn\r\n    |(Benjamin Franklin)\r\n    \"\"\".trimMargin()\r\n```\r\n默认`|`用作边界前缀，不过你也可以通过传参使用其它字符，比如：`trimMargin(\">\")`\r\n\r\n### 字符串模板\r\n字符串可以包含模板表达式，即，片段代码求值结果会合并到字符串中，模板表达式以美元符号(`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=)开头以及由其它简单名字组成。\r\n\r\n```kotlin\r\nval i = 10\r\nval s = \"i = $i\" // 求值结果为 \"i = 10\"\r\n```\r\n或者也可以用大括号包围一个任意表达式\r\n```kotlin\r\nval s = \"abc\"\r\nval str = \"$s.length is ${s.length}\" // 求值结果为： \"abc.length is 3\"\r\n```\r\n原生字符串和转义字符串都支持模板，如果你需要在原生字符串禁用`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=字符（这里不支持反斜杠转义），可以使用以下语法：\r\n```val price = \"\"\"\r\n${\'$\'}9.99\r\n\"\"\"\r\n```","timestamp":1524798865268},{"name":"002-包.md","path":"006-编程语言/005-kotlin/002-基础/002-包.md","content":"# 包\r\n\r\n源码一般以包声明开头：\r\n```kotlin\r\npackae foo.bar\r\nfun baz() {}\r\n\r\nclass Goo{}\r\n\r\n// ...\r\n```\r\n源码文件的所有内容（包括类和函数）都包含在定义的包中，所以上面的示例中， 方法`baz()`的全称应该是`foo.bar.baz()`, 类型`Goo`的全称是`foo.bar.Goo`\r\n\r\n如果没有指定包，所有文件的内容都属于无名的\"default\"包。\r\n\r\n\r\n","timestamp":1524798865268}]